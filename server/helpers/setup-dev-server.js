const fs = require('fs');
const path = require('path');
const MFS = require('memory-fs');
const webpack = require('webpack');
// 监听文件变化
const chokidar = require('chokidar');
const opn = require('opn');
const webpackClientConfig = require('../../build/webpack.client.config');
const webpackServerConfig = require('../../build/webpack.server.config');
const { iterateObject } = require('../../utils');

const readFile = (fileSystem, file) => {
  try {
    return fileSystem.readFileSync(path.join(webpackClientConfig.output.path, file), 'utf-8');
  } catch (error) { console.error(error); }
};

module.exports = function setupDevServer({
  app, templatePath, callback, serverConfig,
}) {
  let bundle;
  let template;
  let clientManifest;

  let ready;
  const readyPromise = new Promise((r) => { ready = r; });
  const update = () => {
    if (bundle && clientManifest) {
      ready();
      callback(bundle, {
        template,
        clientManifest,
      });
    }
  };

  template = fs.readFileSync(templatePath, 'utf-8');
  chokidar.watch(templatePath).on('change', () => {
    template = fs.readFileSync(templatePath, 'utf-8');
    console.log('index.html template updated.');
    update();
  });

  webpackClientConfig.entry.app = ['webpack-hot-middleware/client', webpackClientConfig.entry.app];
  webpackClientConfig.output.filename = '[name].js';
  webpackClientConfig.plugins.push(
    new webpack.HotModuleReplacementPlugin(),
    new webpack.NoEmitOnErrorsPlugin(),
  );

  const clientCompiler = webpack(webpackClientConfig);
  const devMiddleware = require('webpack-dev-middleware')(clientCompiler, {
    publicPath: webpackClientConfig.output.publicPath,
    noInfo: true,
  });

  const hotMiddleware = require('webpack-hot-middleware')(clientCompiler, { heartbeat: 5000 });

  // 监听mock数据变化并实时更新
  const mockRootDir = path.resolve(__dirname, './mock');
  function iterateMock(currentDir) {
    fs.readdirSync(currentDir).forEach((file) => {
      if (file.indexOf('.') === 0) return;
      const currentFile = path.resolve(currentDir, file);
      if (fs.lstatSync(currentFile).isDirectory()) {
        iterateMock(currentFile);
      } else if (path.extname(currentFile) === '.js') {
        const apiMaps = {};
        const currentData = require(currentFile);
        apiMaps[currentData.api] = currentData.response;
        fs.watch(currentFile, (eventType, filename) => {
          const changedFile = path.resolve(currentDir, filename);
          console.info('文件被修改 ', changedFile);
          delete require.cache[changedFile];
          try {
            const changedData = require(changedFile);
            apiMaps[changedData.api] = changedData.response;
            hotMiddleware.publish({ action: 'reload' });
          } catch (error) {
            console.error('mock', error);
          }
        });
        app.all('*', (req, res, next) => {
          let flag = false;
          iterateObject(apiMaps || {}, (response, key) => {
            const tempKey = key.split(' ');
            const method = tempKey[0].trim().toLowerCase();
            const pathname = tempKey[1].trim();
            if (req.path === pathname && req.method.toLowerCase() === method) {
              flag = true;
              res.json(response);
            }
          });
          if (!flag) { next(); }
        });
      }
    });
  }
  if (serverConfig.enableMock) {
    iterateMock(mockRootDir);
  }

  if (serverConfig.autoOpen) {
    devMiddleware.waitUntilValid(() => {
      opn(`http://localhost:${serverConfig.port}`);
    });
  }

  app.use(devMiddleware);
  clientCompiler.plugin('done', (stats) => {
    stats = stats.toJson();
    stats.errors.forEach(err => console.error(err));
    stats.warnings.forEach(err => console.warn(err));
    if (stats.errors.length) return;
    clientManifest = JSON.parse(readFile(
      devMiddleware.fileSystem,
      'vue-ssr-client-manifest.json',
    ));
    update();
  });

  // hot middleware
  app.use(hotMiddleware);

  // watch and update server renderer
  const serverCompiler = webpack(webpackServerConfig);
  const mfs = new MFS();
  serverCompiler.outputFileSystem = mfs;
  serverCompiler.watch({}, (err, stats) => {
    if (err) throw err;
    stats = stats.toJson();
    if (stats.errors.length) return;

    // read bundle generated by vue-ssr-webpack-plugin
    bundle = JSON.parse(readFile(mfs, 'vue-ssr-server-bundle.json'));
    update();
  });

  return readyPromise;
};
